//===================================================
//Г^ГCГЛ(tile.cpp)
//Auhor:Уnз≥ ПC	Date:2023.8.26
//===================================================
#include "tile.h"
#include "texture.h"
#include "sprite.h"
#include "collision.h"
#include "GameEntity/Player/player.h"
#include "GameEntity/Enemy/enemy.h"
#include "GameEntity/Enemy/EnemySpawn.h"
#include "GameEntity/Enemy/PepperEnemy.h"
#include "score.h"
#include "gun.h"
#include <list>
#include <array>
#include <vector>
#include <unordered_map>
#include "input.h"
#include "range_select.h"

#include "GameEntity/MapObject/Tree.h"
#include "GameEntity/MapObject/NekoCastle.h"

#include "GameEntity/MapObject/EnemyCastle.h"

//*****************************************************************************
// ГOГНБ[ГoГЛХѕРФ
//*****************************************************************************
static int g_Ground;	//ФwМiЧpВћГeГNГXГ`ГГФ‘НЖ
static int g_Filter;
static float g_UW;
static float g_VH;
static std::vector<TILE_DATA> g_Map; //Г}ГbГvВћГfБ[Г^
static int g_SpawnTimeCou;
static int g_SpawnTime;
static int g_SpawnNum;
static int g_Wave;
int g_MapSizeX = 10; // Г}ГbГvЙ°ГTГCГY
int g_MapSizeY = 0; // Г}ГbГvПcГTГCГY
size_t g_MapSize = 0;
Player* p_Player;
static int mapInitSizeY;
static int mapInitSizeX;

MAP_DATA_T g_MapInfo[MAP_FRAME_MAX] =
{
	//НґПгНјХWВ∆Г}ГbГvГ`ГbГvСЃРЂВћРЁТи
	//Т Пн
	{ GetTileUV(0), MAP_ATTRIB_NONE, false},	//0Ц≥
	{ GetTileUV(1), MAP_ATTRIB_STOP, false},	//1ТnЦ Нґ
	{ GetTileUV(2), MAP_ATTRIB_STOP, false},	//2ТnЦ Пг
	{ GetTileUV(3), MAP_ATTRIB_STOP, false},	//3ТnЦ ЙE
	{ GetTileUV(4), MAP_ATTRIB_STOP, false},	//4УhВиВ¬В‘ВµИкРF
	{ GetTileUV(5), MAP_ATTRIB_STOP, false},	//5УhВиВ¬В‘Вµ(ПђВ≥ВҐРќ)
	{ GetTileUV(6), MAP_ATTRIB_STOP, false},	//6УhВиВ¬В‘Вµ
	{ GetTileUV(7), MAP_ATTRIB_STOP, false},	//7УhВиВ¬В‘Вµ(СеВЂВҐРќ)
	{ GetTileUV(8), MAP_ATTRIB_STOP, false},	//8УаКpЙE
	{ GetTileUV(9), MAP_ATTRIB_STOP, false},	//9УаКpНґ
	{ GetTileUV(10), MAP_ATTRIB_STOP, false},	//10Ц≥(Т ВиФ≤ВѓХsЙ¬)
	//Р¬
	{ GetTileUV(13), MAP_ATTRIB_STOP, true},	//11ТnЦ Нґ
	{ GetTileUV(14), MAP_ATTRIB_STOP, true},	//12ТnЦ Пг
	{ GetTileUV(15), MAP_ATTRIB_STOP, true},	//13ТnЦ ЙE
	{ GetTileUV(16), MAP_ATTRIB_STOP, false},	//14УhВиВ¬В‘ВµИкРF
	{ GetTileUV(17), MAP_ATTRIB_STOP, false},	//15УhВиВ¬В‘Вµ(ПђВ≥ВҐРќ)
	{ GetTileUV(18), MAP_ATTRIB_STOP, false},	//16УhВиВ¬В‘Вµ
	{ GetTileUV(19), MAP_ATTRIB_STOP, false},	//17УhВиВ¬В‘Вµ(СеВЂВҐРќ)
	{ GetTileUV(20), MAP_ATTRIB_STOP, false},	//18УаКpЙE
	{ GetTileUV(21), MAP_ATTRIB_STOP, false},	//19УаКpНґ

	//О©СR
	{ GetTileUV(24), MAP_ATTRIB_NATURE, false},//20СР
	{ GetTileUV(25), MAP_ATTRIB_NATURE, false},//21СРПђ
	{ GetTileUV(26), MAP_ATTRIB_NATURE, false},//22Й‘Й©РF
	{ GetTileUV(27), MAP_ATTRIB_NATURE, false},//23ВµВяВґ
	//Г}ГbГvГ`ГbГvВћОнЧёХ™НмРђВЈВй
};

//Г}ГbГvГfБ[Г^Б[(1ЙжЦ Х™)
const int P = 'P';	// ГvГМГCГДБ[
const int E = 'E';	// ГGГlГ~Б[
const int E2 = 'E2';	// ГGГlГ~Б[
const int T = 'T';	//ЦЎГIГuГWГFГNГg
const int C = 'C'; //ПйГIГuГWГFГNГg
const int Мы = 1;	// ТnЦ Пг
const int Уc = 11;	// ТnЦ Пг
const int КO = 10;	// ТnЦ Пг
const int TT = 'TT';  //В∆В∞В∆В∞ВћЦЎ
const int ВO = 0;


struct MAP_DATA
{
	std::vector<std::vector<int>> mapData;
	float rate;
};

//КeБXВћСЃРЂВрУьВкВй
// 
//--------------------------------------------------
//ПЙКъГ}ГbГv
std::vector<std::vector<int>> g_MapAttribDataS =
{ {
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{КO,КO,КO,КO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{КO,КO,КO,КO,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //3
	{{КO,КO,КO,КO,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //4 ВўВЏЙжЦ КO
	{{КO,КO,КO,КO,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapDataS{ g_MapAttribDataS, 0.0f };//ФrПoКmЧ¶
//--------------------------------------------------В±ВкВ≈1Г}ГbГv


//--------------------------------------------------
std::vector<std::vector<int>> g_MapAttribData1 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO,ВO,ВO, T,ВO,ВO, E,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //2
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //3
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //4 ВўВЏЙжЦ КO
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData1{ g_MapAttribData1, 35.0f };//ФrПoКmЧ¶
//--------------------------------------------------В±ВкВ≈1Г}ГbГv

std::vector<std::vector<int>> g_MapAttribData2 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO, E, E,ВO,ВO,ВO, E}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,Мы,Мы,Мы,Мы,ВO,ВO,ВO}}, //1
	{{ВO,ВO,Мы,Мы,Мы,Мы,Мы,Мы,Мы,ВO}}, //2
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //3
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //4 ВўВЏЙжЦ КO
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData2{ g_MapAttribData2, 35.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv

std::vector<std::vector<int>> g_MapAttribData3 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO, T,ВO,ВO,ВO,ВO,ВO, T}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{Мы,Мы,ВO,ВO,ВO,Мы,Мы,Мы,ВO,ВO}}, //2
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //3
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //4 ВўВЏЙжЦ КO
	{{Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы,Мы}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData3{ g_MapAttribData3, 35.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv

std::vector<std::vector<int>> g_MapAttribData4 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,E2,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData4{ g_MapAttribData4, 25.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv

std::vector<std::vector<int>> g_MapAttribData5 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO, T,ВO}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,Уc,Уc,ВO,E2,ВO,ВO,ВO,ВO}}, //0
	{{ВO,Уc,Уc,Уc,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{Уc,Уc,Уc,Уc,ВO,ВO,ВO,Уc,Уc,Уc}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData5{ g_MapAttribData5, 25.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv

std::vector<std::vector<int>> g_MapAttribData6 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO, T,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO}}, //1
	{{ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData6{ g_MapAttribData6, 25.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv
// 
std::vector<std::vector<int>> g_MapAttribData7 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,E2,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,E2,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO,ВO,E2,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,ВO}}, //0
	{{ВO,ВO,ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,ВO}}, //1
	{{ВO,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,ВO}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData7{ g_MapAttribData7, 25.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv
// 
std::vector<std::vector<int>> g_MapAttribData8 =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,E2,ВO,ВO,ВO,ВO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO}}, //0
	{{ВO,ВO,Уc,Уc,ВO,ВO,ВO,ВO,Уc,Уc,Уc,Уc,ВO,ВO,ВO}}, //1
	{{ВO,Уc,Уc,Уc,Уc,ВO,ВO,Уc,Уc,Уc,Уc,Уc,Уc,ВO,ВO}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapData8{ g_MapAttribData8, 25.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv
//Г{ГXГ}ГbГv
std::vector<std::vector<int>> g_MapAttribDataG =
{ {
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //2
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //3
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //4
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //5
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //6
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //7
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,E2,E2,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //8
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,E2,E2,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //9
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //0
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO,КO}}, //1
	{{ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,ВO,КO,КO,КO,КO,КO,КO,КO,КO}}, //2
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,КO,КO,КO,КO,КO,КO,КO,КO}}, //3
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,КO,КO,КO,КO,КO,КO,КO,КO}}, //4 ВўВЏЙжЦ КO
	{{Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,Уc,ВO,КO,КO,КO,КO,КO,КO,КO,КO}}, //5 ЙжЦ КO(В±В±В№В≈ХKЧv)
} };

MAP_DATA g_MapDataG{ g_MapAttribDataG, 0.0f };
//--------------------------------------------------В±ВкВ≈1Г}ГbГv



//Г}ГbГvВрВ№В∆ВяВй(ГЙГУГ_ГАРґРђВћМуХв)
std::unordered_map<int, MAP_DATA>g_MapDatas;


//=============================================================================
// ПЙКъЙїПИЧЭ
//=============================================================================
void InitTile(void)
{
	//ФwМiГeГNГXГ`ГГВћУ«ВЁНЮВЁ
	g_Ground = LoadTexture((char*)"data/TEXTURE/MapChip.png");
	g_Filter = LoadTexture((char*)"data/TEXTURE/Filter.png");

	g_UW = 1.0f / MAP_WIDTH_PATTERN;
	g_VH = 1.0f / MAP_HEIGHT_PATTERN;

	for (size_t i = 0; i < g_MapAttribData2.size(); i++)
	{
		for (size_t j = 0; j < g_MapAttribData2[1].size(); j++)
		{
			if (g_MapAttribData2[i][j] == 0)continue;
			g_MapAttribData2[i][j] += 6;
		}
	}
	
	// ФzЧсВрНЗСћВ≥ВєВй
	//-------------------------------------------------------Г}ГbГvВрТ«ЙЅВµВљВзВ±В±В…ЛLУь
	g_MapDatas[0] = g_MapDataS;
	g_MapDatas[1] = g_MapData1;
	g_MapDatas[2] = g_MapData2;
	g_MapDatas[3] = g_MapData3;
	g_MapDatas[4] = g_MapData4;
	g_MapDatas[5] = g_MapData5;
	g_MapDatas[6] = g_MapData6;
	g_MapDatas[7] = g_MapData7;
	g_MapDatas[8] = g_MapData8;
	//-------------------------------------------------------

	std::vector<std::vector<int>> g_MapAttribData;//mapГfБ[Г^ВрМЛНЗВµВљВаВћВрУьВкВй
	g_MapAttribData = g_MapDatas[0].mapData;//Н≈ПЙВћТnМ`ВрСгУь
	for (size_t i = 0; i < MAP_MAX; i++)
	{
		int rate = 0;
		//-------------------------------------------------------В±В±В≈Г}ГbГvВрГЙГУГ_ГАВ…СIТи
		while (rate == 0)
		{
			//0.0fВрУьВкВƒЦ≥ЧЭВвВиПИЧЭ
			if (i <= 5)rate = RandomPercent(g_MapData1.rate, g_MapData2.rate, g_MapData3.rate);
			else if (i <= 10)rate = RandomPercent(g_MapData1.rate, g_MapData2.rate, g_MapData3.rate, g_MapData4.rate, 0.0f, 0.0f, g_MapData7.rate, g_MapData8.rate);
			else if (i <= 15)rate = RandomPercent(0.0f, 0.0f, 0.0, g_MapData4.rate, g_MapData5.rate, g_MapData6.rate, g_MapData7.rate, g_MapData8.rate);
		}
		//-------------------------------------------------------
		g_MapAttribData = combineArrays(g_MapAttribData, g_MapDatas[rate].mapData);
	}
	//Н≈ПIГ}ГbГv
	g_MapAttribData = combineArrays(g_MapAttribData, g_MapDataG.mapData);

	//Г}ГbГvГTГCГYОжУЊ
	mapInitSizeY = g_MapAttribData.size(); // Г}ГbГvПcГTГCГY
	mapInitSizeX = (mapInitSizeY > 0) ? g_MapAttribData[0].size() : 0; // Г}ГbГvЙ°ГTГCГYБiН≈ПЙВћНsВ™ЛуВ≈В»ВҐПкНЗБj

	//ГЙГУГ_ГАГ^ГCГЛФzТu
//-------------------------------------------------------Г^ГCГЛСЭВ¶ВљВзВ±В±ВрХѕНX
	//ГIБ[ГoБ[ГtГНБ[ВµВ»ВҐВжВ§В…ОьВиВ…0ВрУьВкВй
	for (size_t i = 0; i < mapInitSizeY; i++)
	{
		g_MapAttribData[i].push_back(0); //XЦЦФцТ«ЙЅ
		g_MapAttribData[i].insert(g_MapAttribData[i].begin(), 0); //XЦЦФцТ«ЙЅ
	}
	
	//YЦЦФцТ«ЙЅ
	g_MapAttribData.push_back(std::vector<int>(mapInitSizeX + 2));

	//YРжУ™Т«ЙЅ
	g_MapAttribData.insert(g_MapAttribData.begin(), std::vector<int>(mapInitSizeX + 2));

	std::vector<std::vector<int>> g_MapAttribDataCopy = g_MapAttribData;//g_MapAttribDataCopyВрОQП∆ВµВƒg_MapAttribDataВрПСВЂКЈВ¶ВƒВҐВ≠

	int rate = 0;//ГЙГУГ_ГА

	//ОьВиВћПоХсВ©ВзГ^ГCГЛВћМ©ВљЦЏВрХѕНX
	for (int y = 1; y < mapInitSizeY; y++)
	{
		for (int x = 1; x < mapInitSizeX; x++)
		{
			//ГGГУГeГBГeГBВрФzТu
			//ГvГМГCГДБ[
			if (g_MapAttribData[y][x] == P)
			{
				g_MapAttribData[y][x] = 0;
			}
			//ГGГlГ~Б[
			if (g_MapAttribData[y][x] == E)
			{
				g_MapAttribData[y][x] = 0;
				Spawner::Instance()->SetEnemy({ x * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5), y * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5) });
			}
			if (g_MapAttribData[y][x] == E2)
			{
				g_MapAttribData[y][x] = 0;
				int texPepper = LoadTexture((char*)"data/TEXTURE/paperenemy.png");
				Spawner::Instance()->SetFor<PepperEnemy>({ x * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5), y * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5) }, texPepper, 2.0);
			}
			//ЦЎ
			if (g_MapAttribData[y][x] == T)
			{
				g_MapAttribData[y][x] = 0;
				int texTree = LoadTexture((char*)"data/TEXTURE/Tree.png");
				//ЦЎВЌВ≈В©ВҐВћВ≈ТnЦ В…ЦДВ№ВзВ»ВҐВжВ§П≠ВµПгВ…ФzТuВЈВй
				Spawner::Instance()->SetFor<Tree>({ x * static_cast<float>(MAPCHIP_SIZE), y * static_cast<float>(MAPCHIP_SIZE) - 500.0f}, texTree);
			}
			//Пй(ФїТиВћВЁ)
			if (g_MapAttribData[y][x] == C)
			{
				g_MapAttribData[y][x] = 0;
				Spawner::Instance()->SetFor<Castle>({ x * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5), y * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5) });

			}
			//В∆В∞В∆В∞ЦЎ
			if (g_MapAttribData[y][x] == TT)
			{
				g_MapAttribData[y][x] = 0;
				int texSpikeTree = LoadTexture((char*)"data/TEXTURE/SpikeTree.png");
				//Spawner::Instance()->SetFor<EnemyCastle>({ x * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5), y * static_cast<float>(MAPCHIP_SIZE) + static_cast<float>(MAPCHIP_SIZE * 0.5) + 150 }, texSpikeTree);
			}


			switch (g_MapAttribDataCopy[y][x])
			{
			case 1://ТnЦ 
				if (g_MapAttribDataCopy[y - 1][x] == 0 && g_MapAttribDataCopy[y][x - 1] == 0)//ТnЦ НґТ[
				{
					g_MapAttribData[y][x] = 1;
				}
				else if (g_MapAttribDataCopy[y - 1][x] == 0 && g_MapAttribDataCopy[y][x + 1] == 0)//ТnЦ ЙEТ[
				{
					g_MapAttribData[y][x] = 3;
				}
				else if (g_MapAttribDataCopy[y - 1][x] == 0)//ПгВ™ЛуВ»ВзТnЦ Пг
				{
					g_MapAttribData[y][x] = 2;
				}
				else if (g_MapAttribDataCopy[y - 1][x + 1] == 0 && g_MapAttribDataCopy[y][x + 1] == 1)//ТnЦ УаКpЙE
				{
					g_MapAttribData[y][x] = 8;
				}
				else if (g_MapAttribDataCopy[y - 1][x - 1] == 0 && g_MapAttribDataCopy[y][x - 1] == 1)//ТnЦ УаКpЙE
				{
					g_MapAttribData[y][x] = 9;
				}
				else//УhВиВ¬В‘ВЈ
				{
					//ГЙГУГ_ГАВ≈ОнЧёВрМИВяВй
					rate = RandomPercent(40, 15, 40, 5);
					if (rate == 1)g_MapAttribData[y][x] = 4;
					if (rate == 2)g_MapAttribData[y][x] = 5;
					if (rate == 3)g_MapAttribData[y][x] = 6;
					if (rate == 4)g_MapAttribData[y][x] = 7;
				}
				break;

			case 11://ТnЦ Р¬
				if (g_MapAttribDataCopy[y - 1][x] == 0 && g_MapAttribDataCopy[y][x - 1] == 0)//ТnЦ НґТ[
				{
					g_MapAttribData[y][x] = 11;
				}
				else if (g_MapAttribDataCopy[y - 1][x] == 0 && g_MapAttribDataCopy[y][x + 1] == 0)//ТnЦ ЙEТ[
				{
					g_MapAttribData[y][x] = 13;
				}
				else if (g_MapAttribDataCopy[y - 1][x] == 0)//ПгВ™ЛуВ»ВзТnЦ Пг
				{
					g_MapAttribData[y][x] = 12;
				}
				else if (g_MapAttribDataCopy[y - 1][x + 1] == 0 && g_MapAttribDataCopy[y][x + 1] == 11)//ТnЦ УаКpЙE
				{
					g_MapAttribData[y][x] = 18;
				}
				else if (g_MapAttribDataCopy[y - 1][x - 1] == 0 && g_MapAttribDataCopy[y][x - 1] == 11)//ТnЦ УаКpЙE
				{
					g_MapAttribData[y][x] = 19;
				}
				else//УhВиВ¬В‘ВЈ
				{
					//ГЙГУГ_ГАВ≈ОнЧёВрМИВяВй
					rate = RandomPercent(40, 15, 40, 5);
					if (rate == 1)g_MapAttribData[y][x] = 14;
					if (rate == 2)g_MapAttribData[y][x] = 15;
					if (rate == 3)g_MapAttribData[y][x] = 16;
					if (rate == 4)g_MapAttribData[y][x] = 17;
				}
				break;
				break;
			case 80:

				break;
			default:
				break;
			}



		}
	}

	for (int y = 1; y < mapInitSizeY; y++)
	{
		for (int x = 1; x < mapInitSizeX; x++)
		{
			//ТnЦ В≈В†ВкВќСРВ∆В©РґВвВЈ
			if (g_MapAttribData[y][x] == 0)
			{
				if (g_MapAttribData[y + 1][x] == 2)//Т ПнТnЦ 
				{
					rate = RandomPercent(60, 5, 25, 10);
					if (rate == 1) g_MapAttribData[y][x] = 20;
					if (rate == 2) g_MapAttribData[y][x] = 21;
					if (rate == 3) g_MapAttribData[y][x] = 22;
					if (rate == 4) g_MapAttribData[y][x] = 23;
				}
				if (g_MapAttribData[y + 1][x] == 1 || g_MapAttribData[y + 1][x] == 3)//ТnЦ Т[
				{
					g_MapAttribData[y][x] = 21;
				}
			}
		}
	}

	//-------------------------------------------------------

	for (int y = 1; y < mapInitSizeY; y++)
	{
		for (int x = 1; x < mapInitSizeX; x++)
		{
			//Г}ГbГvГfБ[Г^ПЙКъЙї
			TILE_DATA tileData;

			int i = x * (y + 1);
			tileData.attrib = g_MapInfo[g_MapAttribData[y][x]].attrib;
			tileData.initAttrib = tileData.attrib;
			tileData.uv = g_MapInfo[g_MapAttribData[y][x]].uv;
			tileData.XYId = D3DXVECTOR2(x, y);
			tileData.pos.x = x * MAPCHIP_SIZE + (MAPCHIP_SIZE * 0.5);
			tileData.pos.y = y * MAPCHIP_SIZE + (MAPCHIP_SIZE * 0.5);
			tileData.initPos.x = tileData.pos.x;
			tileData.initPos.y = tileData.pos.y;
			tileData.color = D3DXCOLOR(1.0f, 1.0f, 1.0f, 1.0f);
			tileData.move = D3DXVECTOR2(0.0f, 0.0f);
			tileData.spd = TILE_INIT_SPEED;
			tileData.spawn = g_MapInfo[g_MapAttribData[y][x]].spawn;
			tileData.fadeOut = false;

			g_Map.push_back(tileData);

		}
	}

	g_SpawnTimeCou = 0;
	g_SpawnTime = MAP_SPAWN_TIME;
	g_Wave = 0;
	g_SpawnNum = g_Wave + 1; //ИкЙсВћГXГ|Б[ГУРФ

	g_MapSize = g_Map.size();

	for (int i = 0; i < g_MapSize; i++)
	{
		//УGГXГ|Б[ГУ
		if (g_Map[i].spawn == true)
		{
			int ran = RandomPercent(50);
			if (ran == 1)Spawner::Instance()->SetEnemy({ g_Map[i].pos.x, g_Map[i].pos.y - DEFAULT_TILE_SIZE });
		}
	}
}

//=============================================================================
// ПIЧєПИЧЭ
//=============================================================================
void UninitTile(void)
{

}

//=============================================================================
// НXРVПИЧЭ
//=============================================================================
void UpdateTile(void)
{
	g_MapSize = g_Map.size();

	g_SpawnTimeCou = Counter(g_SpawnTimeCou, g_SpawnTime);

	for (int i = 0; i < g_MapSize; i++)
	{
		//ГtГFБ[ГhВрЙЇВ∞ВƒПЅВЈ
		if (g_Map[i].fadeOut)
		{
			g_Map[i].color.a *= 0.95f;

			if (g_Map[i].color.a < 0.01f)
			{
				g_Map[i].fadeOut = false;
				g_Map[i].attrib = MAP_ATTRIB_NONE;
			}
		}
	}
}

//=============================================================================
// Х`ЙжПИЧЭ
//=============================================================================
void DrawTile(void)
{
	SetSamplerState(FILTER_MODE_POINT, ADDRESS_MODE_WRAP);//ГeГNГXГ`ГГВћГtГBГЛГ^Б[ВрOFF

	for (const auto& it : g_Map)
	{
		if (it.attrib != MAP_ATTRIB_NONE)
		{
			DrawSpriteColorRotateCamera
			(
				g_Ground,
				(int)it.pos.x,
				(int)it.pos.y,
				MAPCHIP_SIZE, MAPCHIP_SIZE,	//ХЭБAНВВ≥
				it.uv.x, it.uv.y,			//НґПгUVНјХW
				g_UW, g_VH,					//ГeГNГXГ`ГГХЭБAНВ
				it.color.r, it.color.g, it.color.b, it.color.a,
				0.0f
			);
		}


		/*[ГfГoГbГOЧp]-------------------------------------------*/
		//Г}ГbГvСЃРЂВ≤В∆В…РFХ™ВѓХ\О¶
		//{
		//	switch (it.attrib)
		//	{
		//	case MAP_ATTRIB_STOP:
		//		DrawSpriteColorRotateCamera
		//		(
		//			g_Filter,
		//			it.pos.x, it.pos.y,
		//			MAPCHIP_SIZE, MAPCHIP_SIZE,
		//			0.5f, 0.5f,
		//			1, 1,
		//			0, 0, 1, 0.2f,
		//			0
		//		);

		//	default:
		//		break;
		//	}

		//	if (it.spawn)
		//	{
		//		DrawSpriteColorRotateCamera
		//		(
		//			g_Filter,
		//			it.pos.x, it.pos.y,
		//			MAPCHIP_SIZE, MAPCHIP_SIZE,
		//			0.5f, 0.5f,
		//			1, 1,
		//			1, 0, 1, 0.2f,
		//			0
		//		);
		//	}
		//}
		/*-------------------------------------------------------*/
	}
}

//=============================================================================
// UНјХWВрГZГbГg(ИшРФ : НґПгТ[Вр0ВїВћЙEЧ„ВиВр1,2,3...В∆ВµВљВ∆ВЂВћРФ)
//=============================================================================
float GetTileU(int index)
{
	return ((index % MAP_WIDTH_PATTERN) * (1.0f / MAP_WIDTH_PATTERN));
}

//=============================================================================
// VНјХWВрГZГbГg(ИшРФ : НґПгТ[Вр0ВїВћЙEЧ„ВиВр1,2,3...В∆ВµВљВ∆ВЂВћРФ)
//=============================================================================
float GetTileV(int index)
{
	return ((index / MAP_WIDTH_PATTERN) * (1.0f / MAP_HEIGHT_PATTERN));
}

//=============================================================================
// UVНјХWВрГZГbГg(ИшРФ : НґПгТ[Вр0ВїВћЙEЧ„ВиВр1,2,3...В∆ВµВљВ∆ВЂВћРФ)
//=============================================================================
D3DXVECTOR2 GetTileUV(int index)
{
	D3DXVECTOR2 UV = D3DXVECTOR2(GetTileU(index), GetTileV(index));
	return UV;
}

//=============================================================================
// НјХWТЉЙЇВћГ}ГbГvПоХсВрХ‘ВЈ
// ВOВPВQ 
// ВRВSВT
// ВUВVВW 4В™ИшРФВћНјХW
//=============================================================================
TILE_DATA* GetMapInfo(D3DXVECTOR2 pos)
{
	TILE_DATA* tile = new TILE_DATA[9];

	// ОьИЌВћГ^ГCГЛВћИ ТuВрМvОZ
	int posX = int(pos.x / MAPCHIP_SIZE);
	int posY = int(pos.y / MAPCHIP_SIZE);

	for (int i = 0; i < 9; i++)
	{
		int offsetX = (i % 3) - 1; // ЧсБiНґВ©ВзТЖЙЫВ÷ВћГIГtГZГbГgБj
		int offsetY = (i / 3) - 1; // НsБiПгВ©ВзТЖЙЫВ÷ВћГIГtГZГbГgБj

		int checkX = posX + offsetX;
		int checkY = posY + offsetY;

		// ЛЂКEГ`ГFГbГNБiГ}ГbГvВћФЌИЌКOВрГ`ГFГbГNБj
		if (checkX >= 0 && checkX < g_MapSizeX && checkY >= 0 && checkY < g_MapSizeY)
		{
			int checkXY = checkY * checkX;
			tile[i] = g_Map[checkXY];
		}
		else
		{
			// Г}ГbГvВћФЌИЌКOВћПкНЗБAГfГtГHГЛГgТlВрРЁТиВЈВйВ©ГGГЙБ[ПИЧЭВрНsВ§
			tile[i].attrib = MAP_ATTRIB_ERROR;
			tile[i].pos = D3DXVECTOR2(-1, -1); // Г}ГbГvКOВћНјХWВрО¶ВЈТlВ»В«
		}
	}

	return tile;
}

//=============================================================================
// НјХWТЉЙЇВћГ}ГbГvПоХсВрХ‘ВЈ(Г|ГWГVГЗГУКоПА)
//=============================================================================
TILE_DATA* GetMapInfo(D3DXVECTOR2 pos, D3DXVECTOR2 size)
{
	TILE_DATA* tile = new TILE_DATA[9];
	//ПЙКъЙї
	for (size_t i = 0; i < 9; i++)
	{
		tile[i].attrib = MAP_ATTRIB_ERROR;
		tile[i].pos = D3DXVECTOR2(-1, -1); // Г}ГbГvКOВћНјХWВрО¶ВЈТlВ»В«
	}

	D3DXVECTOR2 sizeH = D3DXVECTOR2(size.x * 0.5f, size.y * 0.5f);

	for (const auto& it : g_Map)
	{
		if (it.color.a < 0.5f) continue;

		if ((it.pos.x < pos.x + size.x && it.pos.x > pos.x - size.x) || (it.pos.y < pos.y + size.y && it.pos.y > pos.y - size.y))
		{
			//Й°ВћГ^ГCГЛОжУЊ
			//ЙE
			if (CollisionRot(pos.x + sizeH.x, pos.y, it.pos.x, it.pos.y, size.x, size.y, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (tile[5].attrib == MAP_ATTRIB_ERROR || (it.attrib != MAP_ATTRIB_NONE && (tile[5].attrib == MAP_ATTRIB_NONE || tile[5].attrib == MAP_ATTRIB_NATURE)))
				{
					tile[5] = it;
				}
			}
			//Нґ
			if (CollisionRot(pos.x - sizeH.x, pos.y, it.pos.x, it.pos.y, size.x, size.y, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (tile[3].attrib == MAP_ATTRIB_ERROR || (it.attrib != MAP_ATTRIB_NONE && (tile[3].attrib == MAP_ATTRIB_NONE || tile[3].attrib == MAP_ATTRIB_NATURE)))
				{
					tile[3] = it;
				}
			}
			//ЙЇ
			if (CollisionRot(pos.x, pos.y + sizeH.y, it.pos.x, it.pos.y, size.x, size.y, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (tile[7].attrib == MAP_ATTRIB_ERROR || (it.attrib != MAP_ATTRIB_NONE && (tile[7].attrib == MAP_ATTRIB_NONE || tile[7].attrib == MAP_ATTRIB_NATURE)))
				{
					tile[7] = it;
				}
			}
			//Пг
			if (CollisionRot(pos.x, pos.y - sizeH.y, it.pos.x, it.pos.y, size.x, size.y, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (tile[1].attrib == MAP_ATTRIB_ERROR || (it.attrib != MAP_ATTRIB_NONE && (tile[1].attrib == MAP_ATTRIB_NONE || tile[1].attrib == MAP_ATTRIB_NATURE)))
				{
					tile[1] = it;
				}
			}
			//ТЖЙЫ
			if (CollisionRot(pos.x, pos.y, it.pos.x, it.pos.y, size.x, size.y, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (tile[4].attrib == MAP_ATTRIB_ERROR || (it.attrib != MAP_ATTRIB_NONE && (tile[4].attrib == MAP_ATTRIB_NONE || tile[4].attrib == MAP_ATTRIB_NATURE)))
				{
					tile[4] = it;
				}
			}
		}
	}

	return tile;
}

//=============================================================================
// УЦВљВиФїТи [ЦяВиТl] 1: Пг, 3: Нґ, 5: ЙE, 7: ЙЇ
//=============================================================================
DIRECTION TileHit(D3DXVECTOR2 pos, float hsp, float vsp, float hitBoxWidth, float hitBoxHeight)
{
	TILE_DATA* tile = GetMapInfo(pos);
	DIRECTION dir = { false };

	for (int j = 0; j < 9; j++)
	{
		if (tile[j].attrib == MAP_ATTRIB_STOP)
		{
			//Й°В…Х«В™В†ВйПкНЗ
			if (CollisionRot(pos.x + hsp, pos.y, tile[j].pos.x, tile[j].pos.y, hitBoxWidth, hitBoxHeight, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (j == 3) dir.left = true;
				if (j == 5) dir.right = true;
			}

			//ПcВ…Х«В™В†ВйПкНЗ
			if (CollisionRot(pos.x, pos.y + vsp, tile[j].pos.x, tile[j].pos.y, hitBoxWidth, hitBoxHeight, MAPCHIP_SIZE, MAPCHIP_SIZE, 0.0f))
			{
				if (j == 1) dir.up = true;
				if (j == 7) dir.down = true;
			}
		}
	}
	delete[] tile;
	return dir;
}

//=============================================================================
// Г}ГbГvВћГ^ГCГЛХѕНX [ИшРФ] 1: М≥ВћГ}ГbГv, 2: ПгПСВЂВЈВйГ}ГbГv, 3: ПгПСВЂВЈВйЙ”ПК
//=============================================================================
void ChangeTile(std::vector<std::vector<int>>& map1, std::vector<std::vector<int>> map2, int group)
{
	int startPos = map2[0].size() * (group - 1);

	for (int i = 0; i < map2.size(); i++)
	{
		for (int j = 0; j < map2[0].size(); j++)
		{
			map1[i].insert(map1[i].begin() + j + startPos, map2[i][j]);
		}
	}
}

void CatTile(float minPosX, float maxPosX)
{

	for (size_t i = 0; i < g_MapSize; i++)
	{
		if (g_Map[i].pos.x >= minPosX && g_Map[i].pos.x <= maxPosX)
		{
			g_Map[i].fadeOut = true;
		}
	}
}

std::vector<std::vector<int>> combineArrays(const std::vector<std::vector<int>>& arr1, const std::vector<std::vector<int>>& arr2)
{
	// arr1В∆arr2ВрЙ°В…МЛНЗВµВƒРVВµВҐФzЧсВрНмРђ
	std::vector<std::vector<int>> combinedArray = arr1;

	for (size_t i = 0; i < arr1.size(); ++i)
	{
		combinedArray[i].insert(combinedArray[i].end(), arr2[i].begin(), arr2[i].end());
	}

	return combinedArray;
}

void SetTilePlayer(Player* player)
{
	p_Player = player;
}

D3DXVECTOR2 GetMapSize()
{
	D3DXVECTOR2 mapSize = D3DXVECTOR2(mapInitSizeX * MAPCHIP_SIZE, mapInitSizeY * MAPCHIP_SIZE);
	return mapSize;
}